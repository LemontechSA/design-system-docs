---
slug: how-we-built-it
title: 쮺칩mo contruimos Suit UI?
authors: [jose, renzo]
---

import { Box } from "lemon-system";
import UI_LIBRARIES_IMAGE from "./ui-libraries.png";
import LIBRARY_SUB_CATEGORIES_IMAGE from "./librarie-subcategories.png";
import CODE_COMPARATION_IMAGE from "./code-comparation.png";
import ESBUILD_COMPARATION_IMAGE from "./esbuild-comparation.png";
import TWIND_TWIN_COMPARATION_IMAGE from "./twind-twin-comparation.png";
import PACKAGE_COMPARATION_IMAGE from "./packages-comparation.png";

<br />

Para el desarrollo de **Suit UI**, la librer칤a de componentes del Design System de [Lemontech](https://www.lemontech.com), hemos tomado distintas decisiones con respecto a implementaciones t칠cnicas. En este blog planteamos las diferentes dificultades t칠cnicas a las que nos hemos visto enfrentados y el c칩mo optamos por solucionarlas.

<!--truncate-->

<br />

> 游뚾 Suit UI sigue en desarrollo, debido a esto puede que algunos elementos escritos aqu칤 con el tiempo cambien o est칠n desactualizados.

<br />

# Requerimientos

Los siguientes requerimientos fueron planteados para Suit UI:

- Debe ser consistente con el Design System de Lemontech.
- Debe ser facilmente adaptable en los equipos de Lemontech.
- No debe generar mayores inconvenientes al ser implementado en nuevas o en ya creadas aplicaciones.

# Decisiones de implementaci칩n

## Enfoque

<br />

<Box className="flex flex-col items-center">
<img
  src={UI_LIBRARIES_IMAGE}
  width="500"
  alt="Categorias de las Librer칤as UI"
/>

_Categorias de Librer칤as UI._

</Box>

<br />

Podemos dividir las librer칤as de componentes en tres grandes categor칤as:

- **CSS++**: Librer칤as que solo entregan un CSS potenciado.
- **Style Systems**: Librer칤as que solo brindan estilos.
- **Behavior Libraries**: Librer칤as que solo ofrecen un manejo del comportamiento.

Tambi칠n existen librer칤as que estan entre las intersecciones de estas categor칤as y que a침aden un conjunto de funcionalidades.

Con Suit UI quer칤amos que el [DX](https://medium.com/swlh/what-is-dx-developer-experience-401a0e44a9d9) (exp. del desarrollador) fuera igual o mejor que trabajando con[MUI](https://mui.com), [Chakra UI](https://chakra-ui.com) y [Mantine](https://mantine.dev). Por lo tanto, implementamos la misma flexibilidad que estos tienen al ser part칤cipe de las 3 categor칤as mencionadas.

<br />

<Box className="flex flex-col items-center">

<img
  src={LIBRARY_SUB_CATEGORIES_IMAGE}
  width="350"
  alt="Sub-categorias de librer칤as UI"
/>

_Sub-categorias de librer칤as UI._

</Box>

<br />

Para que Suit UI fuese facilmente adoptable, era necesario que su estilizaci칩n no fuese compleja y que no se tuviese que lograr hacer con CSS StyleSheets.

Es por este motivo que decidimos que la estilizaci칩n fuese con clases de [Tailwind CSS](https://tailwindcss.com), que era algo que, en algunos equipos de Lemontech, ya estaba siendo aplicado y les facilitiba el desarrollo.

En Chakra UI, MUI y Mantine la estilizaci칩n es mediante **Style Props** (estilos como propiedad) y/o usando la convenci칩n **sx**, usando e inspirandose en librer칤as como [Styled System](https://styled-system.com) y [Theme UI](https://theme-ui.com).

<br />

<Box className="flex flex-col items-center">

<img
  src={CODE_COMPARATION_IMAGE}
  width="500"
  alt="Las 3 formas de estilizar un componente."
/>

</Box>

<br />

Este enfoque de crear una librer칤a la cual, aparte de brindar estilos y comportamiento, se pudiese estilizar con Tailwind CSS es novedoso y no ten칤amos precedentes en los cuales inspirarnos.

Por lo cual investigamos su factibilidad t칠cnica, probando las tres siguientes opciones como librer칤a base de Suit UI:

- [Tailwind CSS](https://tailwindcss.com)
- [Twin.macro](https://github.com/ben-rogerson/twin.macro)
- [Twind](https://twind.dev)

Lo primero que uno se puede preguntar es: 쯣or qu칠 no usar Tailwind CSS en Suit UI? Ser칤a la opci칩n ideal, pero no es algo factible de poder realizarse.

Tailwind CSS funciona con los post-procesador de CSS: [Autoprefixer](https://autoprefixer.github.io) y [PurgeCSS](https://purgecss.com), estos en conjunto pueden inyectar CSS a un fichero CSS StyleSheet para estilizar los componentes con clases de Tailwind CSS.

Debido a lo anterior, es que usando Tailwind CSS no se le podr칤a encargar a Suit UI la responsabilidad de configurar Tailwind CSS, sino que esta es traspasada al que implementa la librer칤a en su aplicaci칩n, y lo mismo pasar칤a con respecto a su configuraci칩n, que depender칤a del framework que est칠 ocupando (create-react-app, Next.js, Vite, etc...)

Otro punto a considerar es en el ambiente desarrollo de Suit UI. Para que fuese posible desarrollar con Tailwind CSS se tendr칤a que implementar una configuraci칩n en la empaquetaci칩n del c칩digo fuente para poder usarse junto con Storybook, luego, crear otra configuraci칩n en la empaquetaci칩n para el bundle que ser칤a distribuido en npm y, por 칰ltimo, se tendr칤a que tener en cuenta el purge al implementar la librer칤a en alguna app.

El conjunto de estas problem치ticas nos hizo decantarnos por las opciones de Tailwind css-in-js probando Twind y Twin.macro.

<br />

<Box className="flex flex-col items-center">

<img
  src={TWIND_TWIN_COMPARATION_IMAGE}
  width="600"
  alt="Comparaci칩n entre Twin.macro y Twind"
/>

_Comparaci칩n entre Twin.macro y Twind._

</Box>

<br />

**Twin.macro** es una librer칤a que funciona con una [Macro](https://github.com/kentcdodds/babel-plugin-macros) de Babel que permite estilizar componentes css-in-js usando clases de Tailwdin CSS y cuya transformaci칩n es hecha en la compilaci칩n.

Esta alternativa, si bien es interesante para ser implementada en aplicaciones, no lo es tanto para librer칤as. Si se implementa en una librer칤a, como en Suit UI, y luego esta es instalada en una app, como la transformaci칩n de Babel es en build time, la estilizaci칩n con clases de Tailwind CSS que se haga en los componentes no se ver칤an reflejados en la app.

En **Twind** es diferente, no es necesario una compilaci칩n previa y en comparaci칩n de otras librer칤as css-in-js su inyecci칩n de CSS es [m치s 칩ptima](https://twind.dev/handbook/introduction.html#benchmarks). Por lo que usar Twind como librer칤a base para Suit UI ser칤a lo m치s sencillo y 칩ptimo, y es por lo cual optamos por utilizarla.

import { Button } from "lemon-system";

<Button className="uppercase p-10" onClick={() => alert("Made with Twind! 游땎")}>
  Press me!
</Button>

<br />
<br />

```js
import { Button } from "suit-ui";

<Button className="uppercase p-10">Press me!</Button>;
```

## Definici칩n de Bundle

<br />

<Box className="flex flex-col items-center">

<img src={ESBUILD_COMPARATION_IMAGE} width="600" alt="ESBuild benchmark" />

_Benchmark https://esbuild.github.io_

</Box>

<br />

Para empaquetar el c칩digo fuente y poder distribuir la librer칤a en npm ten칤amos diferentes opciones:

- [Webpack](https://webpack.js.org)
- [Rollup](https://rollupjs.org/guide/en)
- [Esbuild](https://esbuild.github.io)

Webpack es la soluci칩n m치s com칰n en la actualidad para empaquetar aplicaciones web, pero de poco ESBuild y Rollup han ido tomando m치s espacio por su mayor eficiencia de empaquetaci칩n y su simplicidad al ser configurados.

En comparaci칩n con Rollup y Webpack, la alternativa de Esbuild viene listo, desde su instalaci칩n, para empaquetar jsx y typescript sin necesidad de configurar nada y adem치s de que su rapidez para empaquetar las apps es mucho mayor que las dos alternativas previas hizo que nos decant치ramos por esta opci칩n.

## Administrador de paquetes

<br />

<Box className="flex flex-col items-center">

<img src={PACKAGE_COMPARATION_IMAGE} width="600" alt="Packages benchmark" />

_Benchmark https://pnpm.io/benchmarks._

</Box>

<br />

Como administrador de librer칤as se tomaron en cuenta las siguientes:

- [Npm](https://www.npmjs.com)
- [Yarn](https://yarnpkg.com)
- [Pnpm](https://pnpm.io/es)

Uno de los principios t칠cnicos por lo que nos guiamos para la construcci칩n de Suit UI fue la simplicidad, el evitar implementaciones que no contuviesen mayores beneficios.

Con respecto a Yarn, si bien, sol칤a optarse debido a que era m치s r치pido como administrador de paquetes que npm. En la actualidad no hay gran diferencia entre estas, y a침adiendo el hecho de que Yarn sea externo a Node y no viniese con este instalado como si lo hace Npm es por lo cual que lo descartamos como administradorr de paquetes.

Pnpm nos ofrec칤a una mayor eficiencia que Npm pero nos encontramos con problemas de compatibilidad con otras librer칤as debido a su forma de organizar _node_modules_.

Luego de haber probado las diferentes opciones, decidimos usar npm.

## Repositorio

Para organizar el repositorio se evaluaron dos opciones:

- Monorepo multipaquete usando _turborepo_ [Repositorio de pruebas](https://github.com/rtelenta/test-monorepo-design-system)
- Unica librer칤a [Repositorio de pruebas](https://github.com/josiext/react-library-esbuild)

Elegimos tener una _unica librer칤a_ debido a lo simple que es de mantener y al tama침o del proyecto actualmente. Por otro lado si bien un _monorepo multipaquete_ ofrece ventajas a nivel de organizaci칩n de paquetes y ayuda a evitar problemas entre las dependencias, el setup y el proceso de publicaci칩n es complejo.

Por estas razones creemos que un _monorepo multipaquete_ es una buena opci칩n cuando el proyecto es muy grande, debido a lo f치cil de su organizaci칩n. No se descarta optar por esta opci칩n en un futuro.
