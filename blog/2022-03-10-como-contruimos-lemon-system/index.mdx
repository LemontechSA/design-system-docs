---
slug: how-we-built-it
title: 쮺칩mo contruimos Lemon System?
authors: [jose, renzo]
---

import UI_LIBRARIES_IMAGE from "./ui-libraries.png";
import LIBRARY_SUB_CATEGORIES_IMAGE from "./librarie-subcategories.png";

Para el desarrollo de Lemon System, la librer칤a UI del design system de Lemontech, hemos tomado diferentes decisiones en lo que respecta a implementaciones t칠cnicas. En este blog planteamos las dificultades t칠cnicas a las que nos vimos enfrentados y el c칩mo y por qu칠 optamos por solucionarlas.

<!--truncate-->

> 游뚾 La librer칤a sigue en desarrollo, debido a esto puede que algunos topicos escritos aqu칤 con el tiempo cambien o esten desactualizados.

# Requerimientos

Los siguientes requerimientos fueron planteados para Lemon System:

- Debe ser consistente con el Design System de Lemontech.
- Debe ser facilmente adaptable en los equipos de Lemontech.
- No debe crear mayores inconvenientes al ser implemenado en nuevas o ya creadas aplicaciones.

# Decisiones de implementaci칩n

## Enfoque

<br />

<img
  src={UI_LIBRARIES_IMAGE}
  width="600"
  alt="Clasificaci칩n de Librer칤as m치s populares de UI"
/>

_Clasificaci칩n de Librer칤as m치s populares de UI._

<br />

Existen variados enfoques para definir una librer칤a de interfaces, las cuales las podemos dividir en tres grandes grupos: Las librer칤as que entregan un CSS potenciado con nuevas funcionalidades (CSS++), librer칤as que solamente brindan estilos a los componentes (Style Systems) y librer칤as que ofrecen un manejo del comportamiento de los componentes (Behavior Libraries).

La necesidad principales que se quer칤a cubrir era la de acelerar los desarrollos internos y crear una forma de que estos sean consistentes con el Design System de Lemontech en las diferentes aplicaciones que se desarrollasen, por esto, la mejor opci칩n era optar por una librer칤a que cubriese las 3 categor칤as mencionadas, tal como lo hace [MUI](https://mui.com), la librer칤a UI de React de Google, que brinda tanto nuevas opciones de implementaci칩n de CSS, estilos por defecto y un ya implementado comportamiento para los componentes de la librer칤a.

<br />

<img
  src={LIBRARY_SUB_CATEGORIES_IMAGE}
  width="400"
  alt="Sub-categorias de librer칤as"
/>

_Sub-categorias de librer칤as._

<br />

Una de los puntos a considerar para que la librer칤a fuese facilmente adoptada
era que su estilizaci칩n no fuese dificil y preferiblemente que no se tuviese que
crear CSS StyleSheets sino que fuese simplemente con clases de Tailwind CSS, que
era algo que en ciertos equipos ya estaban acostumbrados y les facilitiba el
desarrollo.

En las librer칤as investigadas: Chakra UI, MUI y Mantine. La estilizaci칩n es mediante estilos como propiedad (Style Props) usando/inspirandose en librer칤as como [Styled System](https://styled-system.com) y [Theme UI](https://theme-ui.com)

![Esbuild comparation](./code-comparation.png)
_Sub-categorias de librer칤as._

Este enfoque de crear una librer칤a la cual, aparte de brindar estilos y comportamiento, se pudiese estilizar con Tailwind CSS es novedoso y no teniamos presedentes en los cuales inspirarnos, por lo cual hicimos una investigaci칩n al respecto para probar su factibilidad t칠cnica.

- Tailwind CSS
- Twin.macro
- Twind

Lo primero que se puede pensar es: 쯣or qu칠 no usar simplemente Tailwind CSS?. Es una pregunta totalmente valida pero que lastitamente resulta dificil el implementarlo.

[Tailwind CSS](https://tailwindcss.com) en una aplicaci칩n de React funciona con los post-procesador de CSS: [Autoprefixer](https://autoprefixer.github.io) y [PurgeCSS](https://purgecss.com) . Juntos pueden inyectar css a un fichero CSS StyleSheet con las clases de Tailwind CSS que son usadas en la app.

La principal complicaci칩n t칠cnica que tiene el implementar Tailwind CSS en la librer칤a directamente es que es imperioso para Tailwind inyectar CSS en un CSS StyleSheet ya que este trabaja con un postCSS.

Debido a lo anterior, este proceso ya no se le puede encargar a la librer칤a sino que la responsabilidad de configurar Tailwind CSS es traspasada al que implementa la librer칤a en su aplicaci칩n, y lo mismo con respecto a su configuraci칩n, que depender칤a del framework que este ocupando (create-react-app, Next.js, Vite, etc...).

Otro punto a considerar es en el ambiente desarrollo, en este se tendr칤a que implementar una configuraci칩n en la empaquetaci칩n del c칩digo fuente para poder userse junto con Storybook, luego, su propia configuraci칩n en la empaquetaci칩n para el bundle que ser칤a distribuido en npm y, por 칰ltimo, se tendr칤a que tener en cuenta el purge que hace Tailwind.

El conjunto de estas problematicos nos hizo decantarnos por las opciones de Tailwind css-in-js como [Twind](https://twind.dev) y [Twin.macro](https://github.com/ben-rogerson/twin.macro).

![Esbuild comparation](./twind-twin-comparation.png)
_Comparaci칩n entre Twin.macro y Twind._

Twin.macro es una librer칤a que funciona con una [Macro](https://github.com/kentcdodds/babel-plugin-macros) de Babel que permite crear componentes css-in-js usando clases de Tailwdin CSS, esta transformaci칩n es hecha en la compilaci칩n.

Esta alternativa si bien es interesante para ser implementada en aplicaciones no lo es tanto para librer칤as. Si se implementa en una librer칤a y luego esta es instalada en una app, como la transformaci칩n de Babel es en build time, la estilizaci칩n con clases de Tailwind CSS que se haga en los componentes no se ver칤an reflejados.

En **Twind** es diferente, no es necesario una compilaci칩n previa y en comparaci칩n de otras librer칤as css-in-js su inyecci칩n de CSS es [m치s optima](https://twind.dev/handbook/introduction.html#benchmarks). Por lo que usar Twind facilmente permitir칤a estilizar los componentes de Lemon System con clases de Tailwind CSS y es por la opcion por la que optamos.

import { Button } from "lemon-system";

<Button className="uppercase p-10" onClick={() => alert("Made with Twind! 游땎")}>
  Press me!
</Button>

<br />
<br />

```js
import { Button } from "lemon-system";

<Button className="uppercase p-10">Press me!</Button>;
```

## Definici칩n de Bundle

Para empaquetar el codigo fuente y poder distribuir la librer칤a en npm teniamos diferentes opciones:

- Webpack
- Rollup
- Esbuild

Uno de los principios que tomamos al optar por soluciones son la simplicidad y la eficienca.

Webpack es la soluci칩n m치s comun actualmente para las aplicaciones web, lo usa **create-react-app** y **next.js** (por el momento) sin embargo la libertad que da para ser configurado complejiza su implementaci칩n en una librer칤a donde debe ser configurado de cero, por otro lado, no es el empaquetador m치s rapido por lo que la agilidad del deploy del proyecto se ver칤a afectado.

Rollup y Esbuild son dos soluciones m치s contemporaneas que webpack, en ambas su implementaci칩n es m치s sencilla y directa, sin embargo, por lejos, era mucho mayor la eficiencia en el tiempo de empaquetado que nos daba Esbuild, que por detras usa el lenguaje Go y compila a lenguaje maquina.

![Esbuild comparation](./esbuild-comparation.png)
_Benchmark https://esbuild.github.io_

## Administrador de paquetes

Como administrador de librer칤as se tomaron en cuenta las siguientes:

- npm
- yarn
- pnpm

Uno de los principios t칠cnicos por lo que nos guiamos para la contrucci칩n de Lemon System fue la simplicidad, el evitar implementaci칩nes que no contuviesen mayores beneficios.

Con respecto a Yarn, si bien, tiempo atras, era optada por usarse en vez de npm debido a que era m치s eficiente como administrador de paquetes, actualmente no hay gran diferenc칤a entre estas, y sumandole el hecho de que yarn sea algo externo a Node y no viniese con este instalado como si lo hace npm es por lo cual que lo descartamos.

Pnpm nos ofrecia una mayor eficiencia que npm, pero decidimos optar por esta ultima sin embargo, esto debido a que con pnpm nos encontramos con problemas de compatibilidad con otras librer칤as debido a su forma de organizar _node_modules_.

![Esbuild comparation](./packages-comparation.png)
_Benchmark https://pnpm.io/benchmarks_

## Repositorio

- Monorepo (turborepo)
- Monolito

_En contrucci칩n..._
