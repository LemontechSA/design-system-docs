---
slug: how-we-built-it
title: ¿Cómo contruimos Lemon System?
authors: [jose, renzo]
---

import { Box } from "lemon-system";
import UI_LIBRARIES_IMAGE from "./ui-libraries.png";
import LIBRARY_SUB_CATEGORIES_IMAGE from "./librarie-subcategories.png";
import CODE_COMPARATION_IMAGE from "./code-comparation.png";
import ESBUILD_COMPARATION_IMAGE from "./esbuild-comparation.png";
import TWIND_TWIN_COMPARATION_IMAGE from "./twind-twin-comparation.png";
import PACKAGE_COMPARATION_IMAGE from "./packages-comparation.png";

Para el desarrollo de Lemon System, la librería UI del design system de Lemontech, hemos tomado diferentes decisiones con respecto a implementaciones técnicas. En este blog planteamos las diferentes dificultades técnicas a las que nos hemos vistos enfrentados y el cómo optamos por solucionarlas.

<!--truncate-->

> 🚧 La librería sigue en desarrollo, debido a esto puede que algunos elementos escritos con el tiempo cambien o esten desactualizados.

# Requerimientos

Los siguientes requerimientos fueron planteados para Lemon System:

- Debe ser consistente con el Design System de Lemontech.
- Debe ser facilmente adaptable en los equipos de Lemontech.
- No debe crear mayores inconvenientes al ser implemenado en nuevas o en ya creadas aplicaciones.

# Decisiones de implementación

## Enfoque

<br />

<Box className="flex flex-col items-center">
<img
  src={UI_LIBRARIES_IMAGE}
  width="600"
  alt="Clasificación de Librerías más populares de UI"
/>

_Clasificación de Librerías más populares de UI._

</Box>

<br />

Existen variados enfoques para definir una librería de interfaces, las cuales las podemos dividir en tres grandes grupos: Las librerías que entregan un CSS potenciado (CSS++), librerías que solamente brindan estilos (Style Systems) y librerías que ofrecen un manejo del comportamiento (Behavior Libraries).

La necesidad principales que se quería cubrir con Lemon System era la de acelerar los desarrollos internos y crear una forma de que estas interfaces de usuario sean consistentes con el Design System de Lemontech en las diferentes aplicaciones que se desarrollasen, por esto, la mejor opción era optar por una librería que cubriese las 3 categorías mencionadas, tal como lo hacen [MUI](https://mui.com), [Chakra UI](https://chakra-ui.com) y [Mantine](https://mantine.dev)

<br />

<Box className="flex flex-col items-center">

<img
  src={LIBRARY_SUB_CATEGORIES_IMAGE}
  width="400"
  alt="Sub-categorias de librerías"
/>

_Sub-categorias de librerías._

</Box>

<br />

Para que la librería fuese facilmente adoptable era necesario que su estilización no fuese compleja y preferiblemente que no se tuviese que crear CSS StyleSheets para esto sino que fuese simplemente con clases de Tailwind CSS, que era algo, que en ciertos equipos, ya estaba siendo aplicado y les facilitiba el desarrollo.

En Chakra UI, MUI y Mantine la estilización es mediante estilos como propiedad (Style Props) o usando la convención xs, usando e inspirandose en librerías como [Styled System](https://styled-system.com) y [Theme UI](https://theme-ui.com).

<br />

<Box className="flex flex-col items-center">

<img
  src={CODE_COMPARATION_IMAGE}
  width="500"
  alt="Las 3 formas de estilizar un componente."
/>

</Box>

<br />

Este enfoque de crear una librería la cual, aparte de brindar estilos y comportamiento, se pudiese estilizar con Tailwind CSS es novedoso y no teniamos presedentes en los cuales inspirarnos, por lo cual hicimos una investigación al respecto para probar su factibilidad técnica probando las tres siguientes opciones:

- [Tailwind CSS](https://tailwindcss.com)
- [Twin.macro](https://github.com/ben-rogerson/twin.macro)
- [Twind](https://twind.dev)

Lo primero que se puede pensar es: ¿por qué no usar simplemente Tailwind CSS en Lemon System y permitir que los desarrolladores estilizen estas con clases de Tailwind?. Es una pregunta totalmente valida pero que lastitamente no es factible.

Tailwind CSS en una aplicación de React funciona con los post-procesador de CSS: [Autoprefixer](https://autoprefixer.github.io) y [PurgeCSS](https://purgecss.com), estos en conjunto pueden inyectar CSS a un fichero CSS StyleSheet con las clases de Tailwind CSS que son usadas en la app.

La principal complicación técnica que tiene el implementar Tailwind CSS en la librería directamente es que es imperioso para Tailwind inyectar CSS en un CSS StyleSheet.

Debido a lo anterior, este proceso ya no se le podría encargar a la librería sino que la responsabilidad de configurar Tailwind CSS es traspasada al que implementa la librería en su aplicación, y lo mismo pasaría con respecto a su configuración, que dependería del framework que este ocupando (create-react-app, Next.js, Vite, etc...).

Otro punto a considerar es en el ambiente desarrollo, en este, para que fuese posible desarrollar con Tailwind CSS se tendría que implementar una configuración en la empaquetación del código fuente para poder userse junto con Storybook, luego, crear otra configuración en la empaquetación para el bundle que sería distribuido en npm y, por último, se tendría que tener en cuenta también el purge al implementar la librería en alguna app.

El conjunto de estas problematicos nos hizo decantarnos por las opciones de Tailwind css-in-js como Twind y Twin.macro.

<br />

<Box className="flex flex-col items-center">

<img
  src={TWIND_TWIN_COMPARATION_IMAGE}
  width="600"
  alt="Comparación entre Twin.macro y Twind"
/>

_Comparación entre Twin.macro y Twind._

</Box>

<br />

Twin.macro es una librería que funciona con una [Macro](https://github.com/kentcdodds/babel-plugin-macros) de Babel que permite estilizar componentes css-in-js usando clases de Tailwdin CSS, esta transformación es hecha en la compilación.

Esta alternativa si bien es interesante para ser implementada en aplicaciones no lo es tanto para librerías. Si se implementa en una librería, como en Lemon System, y luego esta es instalada en una app, como la transformación de Babel es en build time, la estilización con clases de Tailwind CSS que se haga en los componentes no se verían reflejados.

En **Twind** es diferente, no es necesario una compilación previa y en comparación de otras librerías css-in-js su inyección de CSS es [más optima](https://twind.dev/handbook/introduction.html#benchmarks). Por lo que usar Twind facil y optimamente permitiría estilizar los componentes de Lemon System con clases de Tailwind CSS por parte del desarrollador y es por la opcion por la que optamos.

import { Button } from "lemon-system";

<Button className="uppercase p-10" onClick={() => alert("Made with Twind! 😃")}>
  Press me!
</Button>

<br />
<br />

```js
import { Button } from "lemon-system";

<Button className="uppercase p-10">Press me!</Button>;
```

## Definición de Bundle

<br />

<Box className="flex flex-col items-center">

<img src={ESBUILD_COMPARATION_IMAGE} width="600" alt="ESBuild benchmark" />

_Benchmark https://esbuild.github.io_

</Box>

<br />

Para empaquetar el codigo fuente y poder distribuir la librería en npm teniamos diferentes opciones:

- Webpack
- Rollup
- Esbuild

Uno de los principios que tomamos al optar por soluciones son la simplicidad y la eficienca.

Webpack es la solución más comun actualmente para las aplicaciones web, lo usa **create-react-app** y **next.js** (por el momento) sin embargo la libertad que da para ser configurado complejiza su implementación en una librería donde debe ser configurado de cero, por otro lado, no es el empaquetador más rapido por lo que la agilidad del deploy del proyecto se vería afectado.

Rollup y Esbuild son dos soluciones más contemporaneas que webpack, en ambas su implementación es más sencilla y directa, sin embargo, por lejos, era mucho mayor la eficiencia en el tiempo de empaquetado que nos daba Esbuild, que por detras usa el lenguaje Go y compila a lenguaje maquina.

## Administrador de paquetes

<br />

<Box className="flex flex-col items-center">

<img src={PACKAGE_COMPARATION_IMAGE} width="600" alt="Packages benchmark" />

_Benchmark https://pnpm.io/benchmarks._

</Box>

<br />

Como administrador de librerías se tomaron en cuenta las siguientes:

- npm
- yarn
- pnpm

Uno de los principios técnicos por lo que nos guiamos para la contrucción de Lemon System fue la simplicidad, el evitar implementaciónes que no contuviesen mayores beneficios.

Con respecto a Yarn, si bien, tiempo atras, era optada por usarse en vez de npm debido a que era más eficiente como administrador de paquetes, actualmente no hay gran diferencía entre estas, y sumandole el hecho de que yarn sea algo externo a Node y no viniese con este instalado como si lo hace npm es por lo cual que lo descartamos.

Pnpm nos ofrecia una mayor eficiencia que npm, pero decidimos optar por esta ultima sin embargo, esto debido a que con pnpm nos encontramos con problemas de compatibilidad con otras librerías debido a su forma de organizar _node_modules_.

## Repositorio

- Monorepo (turborepo)
- Monolito

_En contrucción..._
